/**
 * \file spirit2json.h
 * \author Stefan Hacker
 * \copyright \verbatim
 *
 * Copyright (c) 2011, Stefan Hacker <dd0t@users.sourceforge.net>
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the authors nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * \endverbatim
 */

/**
 * \mainpage Overview
 *
 * spirit2json is a json parser/generator written in C++ using the Boost Spirit library (http://boost-spirit.com/).
 *
 * \section Usage
 * Use spirit2::parse() to parse json and spirit2::generate() to generate it.
 */
#ifndef SPIRIT2JSON_H
#define SPIRIT2JSON_H

#include <string>
#include <stdexcept>
#include <ostream>
#include <vector>
#include <map>
#include <cstddef>

#include <boost/version.hpp>
#include <boost/variant.hpp>
#include <boost/config.hpp>

#if !defined(BOOST_VARIANT_NO_FULL_RECURSIVE_VARIANT_SUPPORT) \
	&& BOOST_VERSION < 104700 // Work around incorrect recursive_variant_ definition in older boosts
struct boost::recursive_variant_ {};
#endif

/**
 * \brief Contains everything related spirit2json JSON parser/generator.
 */
namespace spirit2json {

/**
 * \brief Typedef to std::nullptr_t for compilers that support it. Emulate otherwise.
 */
#if defined(BOOST_NO_NULLPTR) // C++03 compat
class JSONNull {
public:
	template<class T>
	operator T*() const { return 0; }

	template <class C, class T>
	operator T C::*() const { return 0; }

	bool operator==(const JSONNull&) const { return true; }
private:
	void operator &() const;
};
#else
typedef std::nullptr_t JSONNull;
#endif

/**
 * \brief which() value enumeration enum for all types that can be contained in a JSONValue.
 * \note Not to confuse with RTTI typeinfo related data. This is boost::variant specific.
 */
enum JSONValueTypes
{
	JSON_STRING, //!< JSONValue(JSONString()).which() value
	JSON_NUMBER, //!< JSONValue(JSONNumber(0)).which() value
	JSON_BOOL,   //!< JSONValue(JSONBool(false)).which() value
	JSON_NULL,   //!< JSONValue(JSONNull()).which() value
	JSON_ARRAY,  //!< JSONValue(JSONArray()).which() value
	JSON_OBJECT  //!< JSONValue(JSONObject()).which() value
};

//! Typedef to std::wstring
typedef std::wstring JSONString;
//! Typedef to double
typedef double JSONNumber;
//! Typedef to bool
typedef bool JSONBool;

/**
 * \brief JSON-AST value type.
 * Used to store the abstract JSON representation generated by the parse function
 * and as the input to the generate and stream generation functionality.
 *
 * \note The recommended way to walk an JSONValue AST is with a boost visitor.
 *
 * Usage:
 * \code
 * wstring answer = generate(JSONValue(42));
 * wstring hello = generate(JSONValue(L"world"));
 * wstring array = generate(JSONValue(JSONArray()));
 * ...
 * JSONValue val(parse(L"{\"hello\":\"world\", \"array\":[4,2]}"));
 * if (val.type() == JSON_OBJECT) {
 *     JSONObject object(boost::get<JSONObject>(val));
 *		...
 * \endcode
 */
typedef boost::make_recursive_variant<
	JSONString,
	JSONNumber,
	JSONBool,
	JSONNull,
	std::vector<boost::recursive_variant_ >,
	std::map<JSONString, boost::recursive_variant_ > >::type JSONValue;

/**
 * \brief JSON-AST array type.
 * A vector storing JSONValue objects.
 * 
 * Usage:
 * \code
 * JSONArray array;
 * array.push_back(JSONValue(L"Hello World"));
 * array.push_back(JSONValue(42));
 * array.push_back(JSONArray());
 * ...
 * wstring json = generate(JSONValue(array));
 * ...
 * wcout << JSONValue(array) << endl;
 * \endcode
 * 
 */
typedef std::vector<JSONValue> JSONArray;

/**
 * \brief JSON-AST object type.
 * A map storing string, JSONValue pairs.
 *
 * Usage:
 * \code
 * JSONObject object;
 * object.insert(JSONObjectPair(L"key", "value"));
 * object.insert(JSONObjectPair(L"the answer to life the universe and everything", 42);
 * object.insert(JSONObjectPair(L"an array", JSONArray());
 * ...
 * wstring json = generate(JSONValue(object));
 * ...
 * wcout << JSONValue(object) << endl;
 * \endcode
 */
typedef std::map<JSONString, JSONValue> JSONObject;

//! Value type for JSONObject
typedef JSONObject::value_type JSONObjectPair;

/**
 * \brief Baseclass for all exceptions in simple2json
 */
class Exception : public std::exception {
	virtual const char* what() const throw() {
		return "spirit2json: Exception";
	}
};

/**
 * \brief Thrown on parser failure.
 */
class ParsingFailed : public Exception {
	virtual const char* what() const throw() {
		return "spirit2json: Failed to parse given json";
	}
};

/**
 * \brief Parse a given JSON string and return its JSONValue representation.
 * \param str JSON string
 * \throw ParsingFailed Parser failure
 * \return JSONValue representation
 */
JSONValue parse(JSONString str);

/**
 * \brief Generate a JSON string representation from a given JSONValue.
 * \param val JSONValue representation
 * \return String representation
 */
JSONString generate(JSONValue& val);

}

/**
 * \brief Stream output operator implementation for JSVONValues.
 * \param output Output stream to write to
 * \param val JSONValue to generate json from
 * \return Given output stream
 */
std::wostream& operator<<(std::wostream& output, spirit2json::JSONValue& val);

#endif
